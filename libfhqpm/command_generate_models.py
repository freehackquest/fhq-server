#!/usr/bin/env python3
##################################################################################
#    __ _
#   / _| |__   __ _       ___  ___ _ ____   _____ _ __
#  | |_| '_ \ / _` | ___ / __|/ _ \ '__\ \ / / _ \ '__|
#  |  _| | | | (_| ||___|\__ \  __/ |   \ V /  __/ |
#  |_| |_| |_|\__, |     |___/\___|_|    \_/ \___|_|
#                |_|
#
# Copyright (c) 2011-2025 FreeHackQuest <freehackquest@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
##################################################################################

""" subcommand calculate statistics by source code """

import os
import sys
import logging
import json

from .pm_config import PmConfig
from .utils_copyrights import UtilsCopyrights
from .utils_strings import UtilsStrings

logging.basicConfig()


class CommandGenerateModels:
    """ CommandGenerateModels """
    def __init__(self, config: PmConfig):
        self.__log = logging.getLogger("CommandGenerateModels")
        self.__log.setLevel(logging.DEBUG)
        self.__config = config
        self.__subcomamnd_name = "generate-models"

    def get_name(self):
        """ return subcommand name """
        return self.__subcomamnd_name

    def do_registry(self, subparsers):
        """ registring sub command """
        _parser_gen_models = subparsers.add_parser(
            name=self.__subcomamnd_name,
            description='Generate models by src/models.json to src/models/'
        )
        _parser_gen_models.set_defaults(subparser=self.__subcomamnd_name)

    def __update_file(self, filepath, content):
        prev_content = ""
        if os.path.isfile(filepath):
            with open(filepath, "rt", encoding="utf-8", newline="\n") as _file_cpp:
                _lines = _file_cpp.readlines()
                prev_content = "".join(_lines)
        if prev_content != content:
            with open(filepath, "wt", encoding="utf-8", newline="\n") as _file_cpp:
                _file_cpp.write(content)
            self.__log.info("Updated file %s", filepath)
        else:
            self.__log.info("NO need Update file %s", filepath)

    def __generate_cpp(self, src_models_dir, modelname, model_fields):
        classname = "Model" + UtilsStrings.snakecase_to_camelcase(modelname)
        content_cpp = [
            UtilsCopyrights.get_cpp_copyright(),
            "// automaticly generated by models.json",
            "",
            "#include \"model_" + modelname + ".h\"",
            "",
            "#include <algorithm>",
            "#include <iostream>",
            "#include <wsjcpp_core.h>",
            "",
            classname + "::" + classname + "() {",
            "  TAG = \"" + classname + "\";"
        ]
        content_cpp_methods = []
        content_cpp_copy = []
        content_cpp_tojson = []
        for fieldname in model_fields:
            field = model_fields[fieldname]
            varname = UtilsStrings.snakecase_to_camelcase(fieldname)
            if 'varname' in field:
                varname = field['varname']
            typefield = field["type"]

            content_cpp_copy.append("  this->set" + varname + "(m.get" + varname + "());")
            if typefield in ("int", "long"):
                content_cpp.append("  m_n" + varname + " = 0;")
                content_cpp_methods.extend([
                    typefield + " " + classname + "::get" + varname + "() const {"
                    " return m_n" + varname + "; }",
                    "void " + classname + "::set" + varname + "(" + typefield + " nVal) {"
                    " m_n" + varname + " = nVal; }",
                    "",
                ])
                content_cpp_tojson.append("  jsonRet[\"" + fieldname + "\"] = m_n" + varname + ";")
            elif typefield == "string":
                content_cpp.append("  m_s" + varname + " = \"\";")
                _const_str = "const std::string &sVal"
                content_cpp_methods.extend([
                    "const std::string &" + classname + "::get" + varname + "() const {"
                    " return m_s" + varname + "; }",
                    "void " + classname + "::set" + varname + "(const std::string &sVal) {",
                    "  m_s" + varname + " = sVal;",
                    "  m_s" + varname + "_lowercase = WsjcppCore::toLower(sVal);",
                    "}",
                    "bool " + classname + "::hasIn" + varname + "_lowercase(" + _const_str + ") {",
                    "  return m_s" + varname + "_lowercase.find(sVal) != std::string::npos;",
                    "}",
                    "",
                ])
                content_cpp_tojson.append("  jsonRet[\"" + fieldname + "\"] = m_s" + varname + ";")
            else:
                sys.exit("Unknown type '" + typefield + "'")
        content_cpp.extend([
            "}",
            "",
            classname + "::~" + classname + "() {",
            "  //",
            "}",
            "",
        ])
        content_cpp.extend(content_cpp_methods)
        content_cpp.append("void " + classname + "::copy(const " + classname + " &m) {")
        content_cpp.extend(content_cpp_copy)
        content_cpp.extend([
            "}",
            "",
            classname + " *" + classname + "::clone() const {",
            "  " + classname + " *pModel = new " + classname + "();",
            "  pModel->copy(*this);",
            "  return pModel;",
            "}",
            "",
            "nlohmann::json " + classname + "::toJson() {",
            "  nlohmann::json jsonRet;"
        ])

        content_cpp.extend(content_cpp_tojson)
        content_cpp.extend([
            "  return jsonRet;",
            "}",
            "",
        ])
        filepath_cpp = os.path.join(src_models_dir, "model_" + modelname + ".cpp")
        self.__update_file(filepath_cpp, "\n".join(content_cpp))

    def __generate_h(self, src_models_dir, modelname, model_fields):
        classname = "Model" + UtilsStrings.snakecase_to_camelcase(modelname)
        content_h = [
            UtilsCopyrights.get_cpp_copyright(),
            "// automaticly generated by models.json",
            "",
            "#pragma once",
            "",
            "#include <json.hpp>",
            "#include <string>",
            "#include <validators.h>",
            "",
            "class " + classname + " {",
            "public:",
            "  " + classname + "();",
            "  ~" + classname + "();",
            "",
        ]
        content_h_private = []
        for fieldname in model_fields:
            field = model_fields[fieldname]
            varname = UtilsStrings.snakecase_to_camelcase(fieldname)
            if 'varname' in field:
                varname = field['varname']
            typefield = field["type"]

            if typefield in ("int", "long"):
                content_h.extend([
                    "  " + typefield + " get" + varname + "() const;",
                    "  void set" + varname + "(" + typefield + " nVal);",
                    "",
                ])
                content_h_private.append("  " + typefield + " m_n" + varname + ";")
            elif typefield == "string":
                content_h.extend([
                    "  const std::string &get" + varname + "() const;",
                    "  void set" + varname + "(const std::string &sVal);",
                    "  bool hasIn" + varname + "_lowercase(const std::string &sVal);",
                    "",
                ])
                content_h_private.extend([
                    "  std::string m_s" + varname + ";",
                    "  std::string m_s" + varname + "_lowercase;",
                ])
            else:
                sys.exit("Unknown type '" + typefield + "'")
        content_h.extend([
            "  void copy(const " + classname + " &m);",
            "  " + classname + " *clone() const;",
            "  nlohmann::json toJson();",
            "",
            "private:",
            "  std::string TAG;",
        ])
        content_h.extend(content_h_private)
        content_h.extend([
            "};",
            "",
        ])
        filepath_h = os.path.join(src_models_dir, "model_" + modelname + ".h")
        self.__update_file(filepath_h, "\n".join(content_h))

    def __generate_model(self, src_models_dir, modelname, model_fields):
        self.__log.info("Processing model %s ...", modelname)
        self.__generate_cpp(src_models_dir, modelname, model_fields)
        self.__generate_h(src_models_dir, modelname, model_fields)

    def execute(self, _):
        """ executing """
        self.__log.info("Start generating models code...")
        root_dir = self.__config.get_root_dir()
        models_json = os.path.join(root_dir, "src", "models.json")
        src_models_dir = os.path.join(root_dir, "src", "models")

        models = None
        with open(models_json, 'rt', encoding="utf-8") as _file:
            models = json.load(_file)

        for modelname in models:
            self.__generate_model(src_models_dir, modelname, models[modelname])

        sys.exit(0)
